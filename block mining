import os
import json
import hashlib
import time
from struct import pack
from io import BytesIO

MEMPOOL_DIRECTORY = "mempool"
OUTPUT_FILENAME = "out.txt"
TARGET_DIFFICULTY = bytes.fromhex("0000ffff00000000000000000000000000000000000000000000000000000000")
RESERVED_WITNESS_VALUE = bytes(32)
MAX_BLOCK_WEIGHT = 4000000

def double_sha256(data):
    return hashlib.sha256(hashlib.sha256(data).digest()).digest()

def load_transactions():
    transactions = []
    for filename in os.listdir(MEMPOOL_DIRECTORY):
        if not filename.endswith('.json'): continue
        path = os.path.join(MEMPOOL_DIRECTORY, filename)
        try:
            with open(path) as f:
                data = json.load(f)
                transactions.extend(data) if isinstance(data, list) else transactions.append(data)
        except Exception as e:
            print(f"Skipping {filename}: {str(e)}")
    return [tx for tx in transactions if isinstance(tx, dict) and 'txid' in tx]

def select_transactions(transactions):
    valid_txs = [tx for tx in transactions if all(k in tx for k in ('fee', 'weight'))]
    valid_txs.sort(key=lambda x: x['fee']/x['weight'], reverse=True)
    selected, total = [], 0
    for tx in valid_txs:
        if (total + tx['weight']) > (MAX_BLOCK_WEIGHT - 4000): continue
        selected.append(tx)
        total += tx['weight']
    return selected, total

def create_coinbase(fees, commitment):
    version = pack('<I', 1)
    marker = b'\x00'
    flag = b'\x01'
    
    # BIP34-compliant scriptSig (height 0)
    script_sig = pack('<B', 4) + b'\x00'*4  # 5-byte script: 04 00000000
    
    tx = BytesIO()
    tx.write(version)          # Version
    tx.write(marker)           # SegWit marker
    tx.write(flag)             # SegWit flag
    tx.write(b'\x01')          # 1 input
    tx.write(bytes(32))        # Null prev_hash
    tx.write(pack('<I', 0xFFFFFFFF))  # Prev_index
    tx.write(bytes([len(script_sig)]))  # ScriptSig length
    tx.write(script_sig)       # ScriptSig
    tx.write(b'\xFF'*4)        # Sequence
    tx.write(b'\x02')          # 2 outputs
    
    # Miner reward output (P2PKH)
    tx.write(pack('<Q', 5000000000 + fees))
    tx.write(b'\x19')  # 25-byte script
    tx.write(bytes.fromhex('76a914000000000000000000000000000000000000000088ac'))
    
    # Witness commitment output
    commitment_script = bytes.fromhex('6a24aa21a9ed') + commitment
    tx.write(b'\x00'*8)  # 0 value
    tx.write(bytes([len(commitment_script)]))
    tx.write(commitment_script)
    
    # Witness data
    tx.write(b'\x01')           # 1 witness item
    tx.write(b'\x20')           # 32-byte reserved value
    tx.write(RESERVED_WITNESS_VALUE)
    tx.write(pack('<I', 0))     # Locktime
    
    return tx.getvalue()

def compute_merkle_root(items):
    if not items: return bytes(32)
    hashes = [bytes.fromhex(x)[::-1] for x in items]
    while len(hashes) > 1:
        if len(hashes) % 2: hashes.append(hashes[-1])
        hashes = [double_sha256(hashes[i] + hashes[i+1]) for i in range(0, len(hashes), 2)]
    return hashes[0]

def compute_witness_root(wtxids):
    if not wtxids: return bytes(32)
    leaves = [bytes(32)] + [bytes.fromhex(wtxid)[::-1] for wtxid in wtxids[1:]]
    while len(leaves) > 1:
        if len(leaves) % 2: leaves.append(leaves[-1])
        leaves = [double_sha256(a + b) for a,b in zip(leaves[::2], leaves[1::2])]
    return leaves[0]

def mine_block(merkle_root):
    version = pack('<I', 0x20000000)
    prev_hash = bytes(32)
    timestamp = pack('<I', int(time.time()))
    bits = pack('<I', 0x1f00ffff)
    
    header = version + prev_hash + merkle_root + timestamp + bits
    target = TARGET_DIFFICULTY
    
    for nonce in range(0, 0xFFFFFFFF):
        full_header = header + pack('<I', nonce)
        if len(full_header) != 80: continue
        block_hash = double_sha256(full_header)[::-1]
        if block_hash < target:
            return full_header, nonce
    raise ValueError("No valid nonce found")

# Execution flow
transactions = load_transactions()
selected, _ = select_transactions(transactions)
fees = sum(tx['fee'] for tx in selected)

# First pass: temporary coinbase
temp_coinbase = create_coinbase(fees, bytes(32))
wtxids = [double_sha256(temp_coinbase)[::-1].hex()]

# Collect wtxids for non-coinbase transactions
for tx in selected:
    wtxid = double_sha256(bytes.fromhex(tx['hex']))[::-1].hex()
    wtxids.append(wtxid)

# Compute witness commitment
witness_root = compute_witness_root(wtxids)
witness_commitment = double_sha256(witness_root + RESERVED_WITNESS_VALUE)

# Final coinbase with actual commitment
coinbase = create_coinbase(fees, witness_commitment)
coinbase_wtxid = double_sha256(coinbase)[::-1].hex()

# Build final transaction lists
txids = [coinbase_wtxid] + [tx['txid'] for tx in selected]
merkle_root = compute_merkle_root(txids)

# Mine block
header, nonce = mine_block(merkle_root)

# Write output
with open(OUTPUT_FILENAME, 'w') as f:
    f.write(header.hex() + '\n')
    f.write(coinbase.hex() + '\n')
    f.write('\n'.join([coinbase_wtxid] + [tx['txid'] for tx in selected]))
